import reimport jsonimport timeimport asynciofrom typing import Dict, Any, Listfrom langgraph.graph import StateGraph, ENDfrom langchain_openai import ChatOpenAIfrom langchain.prompts import ChatPromptTemplatefrom langchain.schema import HumanMessage, SystemMessagefrom .advanced_chatbot_models import AdvancedChatbotStatefrom .api import fetch_quote, fetch_company_overview, fetch_rsi, fetch_macd, fetch_sma, fetch_news_sentimentclass AdvancedIntentClassifier:    def __init__(self):        self.llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0.1)        self.prompt = ChatPromptTemplate.from_messages([            ("system", """ë‹¹ì‹ ì€ ìµœê³ ê¸‰ ê¸ˆìœµ ë°ì´í„° ë¶„ì„ ì „ë¬¸ê°€ì…ë‹ˆë‹¤. ì‚¬ìš©ìì˜ ì§ˆë¬¸ì„ ì •í™•íˆ ë¶„ì„í•˜ì—¬ ë‹¤ìŒê³¼ ê°™ì´ ë¶„ë¥˜í•˜ì„¸ìš”:ğŸ¯ **ë¶„ë¥˜ ì¹´í…Œê³ ë¦¬:**1. **stock_quote**: ì£¼ì‹ í˜„ì¬ê°€, ì‹œì„¸, ê°€ê²© ì¡°íšŒ2. **company_overview**: íšŒì‚¬ ì •ë³´, ê°œìš”, ì¬ë¬´ì§€í‘œ3. **technical_analysis**: RSI, MACD, SMA ë“± ê¸°ìˆ ì  ë¶„ì„4. **market_sentiment**: ë‰´ìŠ¤, ê°ì • ë¶„ì„, ì‹œì¥ ë™í–¥5. **portfolio_analysis**: í¬íŠ¸í´ë¦¬ì˜¤ ë¶„ì„, ë¹„êµğŸ” **ì—”í‹°í‹° ì¶”ì¶œ:**- symbol: ì£¼ì‹ ì‹¬ë³¼ (ëŒ€ë¬¸ì)- timeframe: daily, weekly, monthly- indicators: RSI, MACD, SMA ë“±- sentiment_keywords: ë‰´ìŠ¤, ê°ì •, ì‹œì¥ ë“±ì‘ë‹µ í˜•ì‹ (JSON):{{    "intent": "ë¶„ë¥˜ëœ ì¸í…íŠ¸",    "confidence": 0.95,    "entities": {{        "symbol": "AAPL",        "timeframe": "daily",        "indicators": ["RSI"]    }},    "reasoning": "ë¶„ë¥˜ ì´ìœ "}}"""),            ("human", "ì§ˆë¬¸: {query}")        ])        def classify(self, state: AdvancedChatbotState) -> AdvancedChatbotState:        start_time = time.time()                try:            chain = self.prompt | self.llm            result = chain.invoke({"query": state["user_query"]})                        # JSON íŒŒì‹± ì‹œë„            try:                parsed = json.loads(result.content)                intent = parsed.get("intent", "stock_quote")                confidence = parsed.get("confidence", 0.8)                entities = parsed.get("entities", {})            except json.JSONDecodeError:                # í´ë°±: ê·œì¹™ ê¸°ë°˜ ë¶„ë¥˜                intent, confidence, entities = self._fallback_classification(state["user_query"])                        # ì‹¬ë³¼ì´ ì—†ìœ¼ë©´ ì¶”ì¶œ ì‹œë„            if "symbol" not in entities:                entities["symbol"] = self._extract_symbol(state["user_query"])                        return {                **state,                "intent": intent,                "confidence": confidence,                "entities": entities,                "step_count": state["step_count"] + 1,                "processing_time": time.time() - start_time            }                    except Exception as e:            return {                **state,                "intent": "stock_quote",                "confidence": 0.5,                "entities": {"symbol": self._extract_symbol(state["user_query"])},                "error_context": f"ë¶„ë¥˜ ì˜¤ë¥˜: {str(e)}",                "step_count": state["step_count"] + 1,                "processing_time": time.time() - start_time            }        def _fallback_classification(self, query: str) -> tuple:        """ê·œì¹™ ê¸°ë°˜ í´ë°± ë¶„ë¥˜"""        query_lower = query.lower()                if any(word in query_lower for word in ["í˜„ì¬ê°€", "ì‹œì„¸", "ê°€ê²©", "quote", "price"]):            return "stock_quote", 0.9, {}        elif any(word in query_lower for word in ["íšŒì‚¬", "ì •ë³´", "ê°œìš”", "overview", "company"]):            return "company_overview", 0.9, {}        elif any(word in query_lower for word in ["rsi", "macd", "sma", "ê¸°ìˆ ì ", "ì§€í‘œ"]):            return "technical_analysis", 0.9, {}        elif any(word in query_lower for word in ["ë‰´ìŠ¤", "ê°ì •", "sentiment", "ì‹œì¥"]):            return "market_sentiment", 0.9, {}        else:            return "stock_quote", 0.7, {}        def _extract_symbol(self, query: str) -> str:        symbols = re.findall(r'\b[A-Z]{2,5}\b', query.upper())        return symbols[0] if symbols else "AAPL"class AdvancedDataFetcher:    def __init__(self):        self.api_key = "384RIRA03BKUSJSV"        async def fetch_data(self, state: AdvancedChatbotState) -> AdvancedChatbotState:        start_time = time.time()        intent = state["intent"]        entities = state["entities"]        symbol = entities.get("symbol", "AAPL")                try:            if intent == "stock_quote":                data = await fetch_quote(symbol=symbol)                data_source = "AlphaVantage Global Quote"                            elif intent == "company_overview":                data = await fetch_company_overview(symbol=symbol)                data_source = "AlphaVantage Company Overview"                            elif intent == "technical_analysis":                indicators = entities.get("indicators", ["RSI"])                data = {}                for indicator in indicators:                    if indicator.upper() == "RSI":                        data["RSI"] = await fetch_rsi(                            symbol=symbol,                            interval="daily",                            time_period=14,                            series_type="close"                        )                    elif indicator.upper() == "MACD":                        data["MACD"] = await fetch_macd(                            symbol=symbol,                            interval="daily",                            series_type="close"                        )                    elif indicator.upper() == "SMA":                        data["SMA"] = await fetch_sma(                            symbol=symbol,                            interval="daily",                            time_period=20,                            series_type="close"                        )                data_source = "AlphaVantage Technical Indicators"                            elif intent == "market_sentiment":                data = await fetch_news_sentiment(tickers=symbol)                data_source = "AlphaVantage News Sentiment"                            else:                data = await fetch_quote(symbol=symbol)                data_source = "AlphaVantage Default"                        return {                **state,                "financial_data": data,                "data_source": data_source,                "step_count": state["step_count"] + 1,                "processing_time": state["processing_time"] + (time.time() - start_time)            }                    except Exception as e:            return {                **state,                "financial_data": {"error": str(e)},                "error_context": f"ë°ì´í„° ì¡°íšŒ ì˜¤ë¥˜: {str(e)}",                "step_count": state["step_count"] + 1,                "processing_time": state["processing_time"] + (time.time() - start_time)            }class AdvancedAnalysisAgent:    def __init__(self):        self.llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0.3)        def format_number(self, value):        """ìˆ«ì í¬ë§·íŒ… (ê¸°ì¡´ ê³ í’ˆì§ˆ í¬ë§·íŒ… ìœ ì§€)"""        try:            if value == 'N/A' or value is None or value == 'None':                return 'N/A'                        if isinstance(value, str):                clean_value = value.replace(',', '')                num = float(clean_value)            else:                num = float(value)                        if num == int(num):                num = int(num)                return f"{num:,}"            else:                return f"{num:,.2f}"                        except (ValueError, TypeError):            return str(value)        def analyze(self, state: AdvancedChatbotState) -> AdvancedChatbotState:        start_time = time.time()        data = state["financial_data"]        intent = state["intent"]        entities = state["entities"]        symbol = entities.get("symbol", "UNKNOWN")                if not data or "error" in data:            analysis = f"âŒ {symbol} ë°ì´í„° ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: {data.get('error', 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜')}"        else:            analysis = self._create_advanced_analysis(data, intent, symbol, entities)                return {            **state,            "analysis_result": analysis,            "step_count": state["step_count"] + 1,            "processing_time": state["processing_time"] + (time.time() - start_time)        }        def _create_advanced_analysis(self, data: Dict, intent: str, symbol: str, entities: Dict) -> str:        """ê³ ê¸‰ ë¶„ì„ ìƒì„± (ê¸°ì¡´ í’ˆì§ˆ ìœ ì§€ + AI ì¸ì‚¬ì´íŠ¸ ì¶”ê°€)"""                if intent == "stock_quote" and "Global Quote" in data:            quote = data["Global Quote"]            price = quote.get("05. price", "N/A")            change = quote.get("09. change", "N/A")            change_percent = quote.get("10. change percent", "N/A")            volume = quote.get("06. volume", "N/A")            prev_close = quote.get("08. previous close", "N/A")            high = quote.get("03. high", "N/A")            low = quote.get("02. low", "N/A")            trading_day = quote.get("07. latest trading day", "N/A")                        # ê±°ë˜ëŸ‰ í¬ë§·íŒ…            formatted_volume = self.format_number(volume)                        # ë³€ë™ë¥  ë¶„ì„            try:                change_num = float(change) if change != "N/A" else 0                change_percent_num = float(change_percent.replace('%', '')) if change_percent != "N/A" else 0                                if change_num > 5 or change_percent_num > 3:                    trend = "ğŸš€ ê¸‰ë“±"                    insight = "ê°•í•œ ìƒìŠ¹ ëª¨ë©˜í…€"                elif change_num > 0:                    trend = "ğŸ“ˆ ìƒìŠ¹"                    insight = "ê¸ì •ì  íë¦„"                elif change_num < -5 or change_percent_num < -3:                    trend = "ğŸ“‰ ê¸‰ë½"                    insight = "ê°•í•œ í•˜ë½ ì••ë ¥"                elif change_num < 0:                    trend = "ğŸ”» í•˜ë½"                    insight = "ì•½ì„¸ íë¦„"                else:                    trend = "ğŸ“Š ë³´í•©"                    insight = "íš¡ë³´ íŒ¨í„´"                                    # ê±°ë˜ëŸ‰ ë¶„ì„                try:                    volume_num = int(volume.replace(',', '')) if volume != "N/A" else 0                    if volume_num > 10000000:                        volume_insight = "ğŸ”¥ ê³ ê±°ë˜ëŸ‰"                    elif volume_num > 1000000:                        volume_insight = "ğŸ“Š ë³´í†µê±°ë˜ëŸ‰"                    else:                        volume_insight = "ğŸ”‡ ì €ê±°ë˜ëŸ‰"                except:                    volume_insight = "ğŸ“Š ê±°ë˜ëŸ‰ ì •ë³´ ì—†ìŒ"                                except:                trend = "ğŸ“Š ë³€ë™ì—†ìŒ"                insight = "ë°ì´í„° ë¶„ì„ ë¶ˆê°€"                volume_insight = "ê±°ë˜ëŸ‰ ë¶„ì„ ë¶ˆê°€"                        return f"""ğŸ“Š **{symbol} ì‹¤ì‹œê°„ ì£¼ì‹ ë¶„ì„**ğŸ’° **ê°€ê²© ì •ë³´:**â€¢ í˜„ì¬ê°€: ${price}â€¢ ë³€ë™: {change} ({change_percent}) {trend}â€¢ ê³ ê°€: ${high}â€¢ ì €ê°€: ${low}â€¢ ì´ì „ ì¢…ê°€: ${prev_close}ğŸ“ˆ **ê±°ë˜ ì •ë³´:**â€¢ ê±°ë˜ëŸ‰: {formatted_volume} ì£¼ {volume_insight}ğŸ§  **AI ë¶„ì„:**â€¢ ì‹œì¥ ìƒí™©: {insight}â€¢ ì¶”ì²œ: {"ë§¤ìˆ˜ ê´€ì‹¬" if change_num > 2 else "ê´€ë§" if change_num > -2 else "ì£¼ì˜ í•„ìš”"}â° **ì—…ë°ì´íŠ¸:** {trading_day}ğŸ“Š **ì‹ ë¢°ë„:** {state.get('confidence', 0.8)*100:.0f}%"""        elif intent == "company_overview" and "Symbol" in data:            # ê¸°ì¡´ ê³ í’ˆì§ˆ íšŒì‚¬ ì •ë³´ í¬ë§·íŒ… ìœ ì§€            market_cap = data.get('MarketCapitalization', 'N/A')            if market_cap != 'N/A' and market_cap != 'None' and market_cap is not None:                try:                    mc_num = int(market_cap)                    if mc_num >= 1000000000000:  # 1ì¡° ì´ìƒ                        market_cap = f"${mc_num/1000000000000:.1f}T"                    elif mc_num >= 1000000000:                        market_cap = f"${mc_num/1000000000:.1f}B"                    elif mc_num >= 1000000:                        market_cap = f"${mc_num/1000000:.1f}M"                    else:                        market_cap = f"${mc_num:,}"                except:                    market_cap = f"${market_cap}"                        # P/E ë¹„ìœ¨ ë¶„ì„            pe_ratio = data.get('PERatio', 'N/A')            pe_analysis = ""            investment_grade = "ë¶„ì„ í•„ìš”"            if pe_ratio != 'N/A' and pe_ratio != 'None' and pe_ratio is not None:                try:                    pe_num = float(pe_ratio)                    if pe_num < 10:                        pe_analysis = " (ğŸ’ ë§¤ìš° ì €í‰ê°€)"                        investment_grade = "ğŸ’š ê°•ë ¥ ë§¤ìˆ˜"                    elif pe_num < 15:                        pe_analysis = " (ğŸ’° ì €í‰ê°€ ê°€ëŠ¥)"                        investment_grade = "ğŸ’™ ë§¤ìˆ˜ ê²€í† "                    elif pe_num < 25:                        pe_analysis = " (ğŸ“Š ì ì • ìˆ˜ì¤€)"                        investment_grade = "ğŸ’› ê´€ë§"                    else:                        pe_analysis = " (âš ï¸ ê³ í‰ê°€ ìœ„í—˜)"                        investment_grade = "ğŸ§¡ ì£¼ì˜ í•„ìš”"                except:                    pass                        # ë°°ë‹¹ìˆ˜ìµë¥  ë¶„ì„            dividend_yield = data.get('DividendYield', 'N/A')            dividend_analysis = ""            if dividend_yield != 'N/A' and dividend_yield != 'None' and dividend_yield is not None:                try:                    div_num = float(dividend_yield)                    dividend_yield = f"{div_num*100:.2f}%"                    if div_num > 0.05:                        dividend_analysis = " (ğŸ¯ ê³ ë°°ë‹¹)"                    elif div_num > 0.02:                        dividend_analysis = " (ğŸ’° ë°°ë‹¹ ì–‘í˜¸)"                    else:                        dividend_analysis = " (ğŸ“Š ë‚®ì€ ë°°ë‹¹)"                except:                    dividend_yield = f"{dividend_yield}%"            else:                dividend_yield = "ì—†ìŒ"                        return f"""ğŸ¢ **{data.get('Name', symbol)} ì‹¬ì¸µ ë¶„ì„**ğŸ­ **ê¸°ë³¸ ì •ë³´:**â€¢ ì—…ì¢…: {data.get('Sector', 'N/A')}â€¢ ì‚°ì—…: {data.get('Industry', 'N/A')}â€¢ êµ­ê°€: {data.get('Country', 'N/A')}â€¢ í†µí™”: {data.get('Currency', 'N/A')}ğŸ’¹ **íˆ¬ì ì§€í‘œ:**â€¢ ì‹œê°€ì´ì•¡: {market_cap}â€¢ P/E ë¹„ìœ¨: {pe_ratio}{pe_analysis}â€¢ PEG ë¹„ìœ¨: {data.get('PEGRatio', 'N/A')}â€¢ ë°°ë‹¹ìˆ˜ìµë¥ : {dividend_yield}{dividend_analysis}ğŸ“Š **ì£¼ê°€ ì •ë³´:**â€¢ 52ì£¼ ìµœê³ ê°€: ${data.get('52WeekHigh', 'N/A')}â€¢ 52ì£¼ ìµœì €ê°€: ${data.get('52WeekLow', 'N/A')}â€¢ 50ì¼ ì´í‰: ${data.get('50DayMovingAverage', 'N/A')}â€¢ 200ì¼ ì´í‰: ${data.get('200DayMovingAverage', 'N/A')}ğŸ§  **AI íˆ¬ì ë“±ê¸‰:** {investment_grade}ğŸ’¼ **íšŒì‚¬ ê°œìš”:**{data.get('Description', 'N/A')[:250]}...ğŸ“Š **ë¶„ì„ ì‹ ë¢°ë„:** {state.get('confidence', 0.8)*100:.0f}%"""        elif intent == "technical_analysis":            indicators_analysis = []            for indicator, indicator_data in data.items():                if indicator == "RSI" and f"Technical Analysis: {indicator}" in indicator_data:                    indicators_analysis.append(f"ğŸ“ˆ RSI ì§€í‘œ ë°ì´í„° ì¤€ë¹„ ì™„ë£Œ")                elif indicator == "MACD":                    indicators_analysis.append(f"ğŸ“Š MACD ì§€í‘œ ë°ì´í„° ì¤€ë¹„ ì™„ë£Œ")                elif indicator == "SMA":                    indicators_analysis.append(f"ğŸ“‰ SMA ì´ë™í‰ê·  ë°ì´í„° ì¤€ë¹„ ì™„ë£Œ")                        analysis_text = "\n".join(indicators_analysis) if indicators_analysis else "ê¸°ìˆ ì  ë¶„ì„ ë°ì´í„° ì¤€ë¹„ ì¤‘..."                        return f"""ğŸ“ˆ **{symbol} ê¸°ìˆ ì  ë¶„ì„**ğŸ¯ **ìš”ì²­ëœ ì§€í‘œ:** {', '.join(entities.get('indicators', ['RSI']))}{analysis_text}ğŸ§  **AI ë¶„ì„:**â€¢ ê¸°ìˆ ì  ì§€í‘œë¥¼ í†µí•œ ë§¤ë§¤ ì‹ í˜¸ ë¶„ì„â€¢ ì¶”ì„¸ ë³€í™” í¬ì°© ë° ì§€ì§€/ì €í•­ ë ˆë²¨ í™•ì¸â€¢ ëª¨ë©˜í…€ ë¶„ì„ì„ í†µí•œ ì§„ì…/ì²­ì‚° íƒ€ì´ë° ì œì‹œğŸ“Š **ë¶„ì„ ì‹ ë¢°ë„:** {state.get('confidence', 0.8)*100:.0f}%"""        return f"âœ… {symbol}ì— ëŒ€í•œ {intent} ë¶„ì„ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."def determine_routing(state: AdvancedChatbotState) -> str:    """ì§€ëŠ¥ì  ë¼ìš°íŒ…"""    confidence = state.get("confidence", 0.5)        if confidence > 0.8:        return "fetch_data"    else:        return "clarify_intent"def clarify_intent(state: AdvancedChatbotState) -> AdvancedChatbotState:    """ì¸í…íŠ¸ ëª…í™•í™”"""    return {        **state,        "analysis_result": f"""ğŸ¤” **ì§ˆë¬¸ì„ ë” ëª…í™•íˆ í•´ì£¼ì„¸ìš”**ì…ë ¥í•˜ì‹  ë‚´ìš©: "{state['user_query']}"ë¶„ì„ ì‹ ë¢°ë„: {state.get('confidence', 0.5)*100:.0f}%ğŸ’¡ **ì¶”ì²œ ì§ˆë¬¸ í˜•ì‹:**â€¢ `NVDA í˜„ì¬ê°€` - ì‹¤ì‹œê°„ ì£¼ê°€â€¢ `AAPL íšŒì‚¬ ì •ë³´` - ê¸°ì—… ë¶„ì„  â€¢ `TSLA RSI` - ê¸°ìˆ ì  ë¶„ì„â€¢ `MSFT ë‰´ìŠ¤` - ì‹œì¥ ê°ì •ë‹¤ì‹œ ì§ˆë¬¸í•´ì£¼ì„¸ìš”! ğŸš€""",        "step_count": state["step_count"] + 1    }def generate_final_response(state: AdvancedChatbotState) -> AdvancedChatbotState:    """ìµœì¢… ì‘ë‹µ ìƒì„±"""    analysis = state.get("analysis_result", "ë¶„ì„ì„ ì™„ë£Œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")    processing_time = state.get("processing_time", 0)        # ì²˜ë¦¬ ì‹œê°„ ì¶”ê°€    footer = f"\n\nâš¡ **ì²˜ë¦¬ ì‹œê°„:** {processing_time:.2f}ì´ˆ | ğŸ“¡ **ë°ì´í„° ì¶œì²˜:** {state.get('data_source', 'AlphaVantage')}"        return {        **state,        "formatted_response": analysis + footer,        "step_count": state["step_count"] + 1    }def create_advanced_chatbot_graph():    """ê³ ê¸‰ LangGraph ì›Œí¬í”Œë¡œìš°"""        classifier = AdvancedIntentClassifier()    data_fetcher = AdvancedDataFetcher()    analyst = AdvancedAnalysisAgent()        workflow = StateGraph(AdvancedChatbotState)        # ë…¸ë“œ ì¶”ê°€    workflow.add_node("classify_intent", classifier.classify)    workflow.add_node("fetch_data", data_fetcher.fetch_data)    workflow.add_node("analyze_data", analyst.analyze)    workflow.add_node("clarify_intent", clarify_intent)    workflow.add_node("generate_response", generate_final_response)        # ì¡°ê±´ë¶€ ì—£ì§€    workflow.add_conditional_edges(        "classify_intent",        determine_routing,        {            "fetch_data": "fetch_data",            "clarify_intent": "clarify_intent"        }    )        workflow.add_edge("fetch_data", "analyze_data")    workflow.add_edge("analyze_data", "generate_response")    workflow.add_edge("clarify_intent", "generate_response")    workflow.add_edge("generate_response", END)        workflow.set_entry_point("classify_intent")        return workflow.compile()